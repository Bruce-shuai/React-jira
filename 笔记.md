jira 项目需要用到的技术栈： React + hooks + ts + react-query(这是啥？) + react-router + react-toolkit + css in js

react-query 来管理**服务端**全局状态
redux toolkit 管理**客户端**全局状态

可以多对比 React 17 教程

#### 2-1 用 Create react app 初始化项目

如何初始化一个 ts + react 项目方法就不说了。 React17 项目笔记已经说得非常明白了

初始化项目后：src 文件夹里的 react-app-env.d.ts、reportWebVitals.ts、setupTests.ts 这三个文件需知道是有什么作用(目前还未知，但项目完成之后应该是要知道才行的)

**注意**: 源代码里如果要使用图片、字体、文件都应该放在 src 文件夹里，然后放在项目里如模块一般使用，而不是放在如 pulic 这类在 src 文件夹之外的文件里

#### 2-2 配置 eslint、prettier 和 commitlint 规范工程

这一节的配置内容，对于团队的合作、代码格式化有好处(和本次项目其实关系不太大)

**问题 1: 引用文件 相对路径过长**

```
例如： import { calculate } from '../../entry....

解决办法：
首先，在tsconfig.json 文件 加一个配置
"baseUrl": "./src"    // 表示绝对路径会去src文件夹下去找
此时，就可以直接写成  import { calculate } from 'entry';   // 但其实还是有点懵
```

导入文件： import ... from './' 和 没有 './'有啥区别？

**格式化代码**
这个感觉挺牛逼的(挺方便的，只要提交到 git，就会自动格式化代码)
让团队写代码有统一规范的格式：
Prettier 工具
首先安装 Prettier：

```
npm install --save-dev --save-exact prettier

echo {}> .prettierrc.json    // echo 是新建一个文件的意思

npx mrm lint-staged    // Prettier hooks
 npm add eslint-config-prettier// 对eslint 要有一些配置
 .... 还是看视频吧...
```

和 vscode 的 prettier 还是有点区别

**提交 commitlint 这个我其实觉得不太方便，算了，不用，有兴趣就看**

#### 2-3 对比常见 Mock 方案 配置 JSON SERVER

(由于在真实环境中，后端和前端并行开发，所以在前期是没有后端接口可以使用的，所以学会最适合自己的 Mock 数据的方法就是非常重要的，下面列举业界常见的 Mock 方案，并选择其中最合适的方案)

##### 1.代码侵入(直接在代码中写死 Mock 数据，或者请求本地的 JSON 文件)

说实话，React 17 就是用的这种方法 估计是应该项目比较简单的原因

优点: 无
缺点:

1. 和其他方案比 Mock 效果不好
2. 与真实 Server 环境的切换非常麻烦(应该不麻烦吧？！)，一切需要侵入代码切换环境的行为都是不好的

##### 2.请求拦截

代表: Mock.js (这是啥？没用过)
帮我们生成随机数据

优点:

1. (相对于代码侵入而言)与前端代码分离
2. 可生成随机数据

缺点:

1. 数据都是动态生成的假数据，无法真实模拟增删改查的情况
2. 只支持 ajax,不支持 fetch

##### 3. 接口管理工具

代表: rap、swagger, moco, yapi(大公司才有)

优点：

1. 配置功能强大，接口管理与 Mock 一体，后端修改接口 mock 也跟着更改，可靠

缺点：

1. 配置复杂，依赖后端，可能会出现后端不愿意出售，或者等配置完了，接口也开发初拉力了的情况。
2. 一般作为大团队的基础建设而存在，没有这个条件的话慎重考虑

##### 4. 本地 node 服务器

代表：json-server

优点：

1. 配置简单，json-server 甚至可以 0 代码，30 秒就启动一个 REST api Server(又是 rest api)
2. 自定义程度高，一切尽在掌握中
3. 增删改查真实模拟
   缺点：
4. 与接口管理工具相比，无法随着后端 api 的修改而自动修改(这个自己也用不着)

```
安装方法：
npm i json-server -g   // 加上sudo 表示全局

启动server： json-server --watch json文件

结合postman 来使用
```

使用 Postman 注意下图几点
必须是 POST 请求 才能设置请求体。且格式应该为 json
![注意事项](./imgs/json-server注意.png)

有一个比较神奇的点： 我通过 postman 可以更改已经有的数据。更改方法竟然是先在 url 后面/id 跟一个要更改内容的 id。 然后把请求方式改为 PATCH。这是什么操作？(为什么会这样？)。删除方式就是 DELETE

url 后跟参数，这里的内容要多研究研究啊

妈的，什么时候我竟然安装了 yarn 的！哈哈

```
在项目中使用json-server
1. yarn add json-server -D
2. 在根目录新建一个文件夹：__json_server_mock__ (前面__表示文件夹是作为辅助文件存在的)
3. ...
4. 运行： npm run json-server
```

[fetch 知识](https://zhuanlan.zhihu.com/p/24594294)

[PATCH 和 PUT 方法的区别](https://segmentfault.com/q/1010000005685904)

#### 3-1 用 JSX 列表渲染开发工程列表页面

先用 js 来写列表渲染。后面再用 ts 来写

这里很有意思，把一个大组件(ProjectListScreen) 由几个小组件(List 组件、SearchPanel 组件)来拼凑出来

并且这个项目中，起文件名的方式是 - 代替驼峰命名(search-panel 代替 SearchPanel)

> 这一节的重点在于 js 和 react 结合后对于 input、option、onChange 的掌握如何！

**因此，总结一点小知识**

- input 标签 常用 的 type 类型
- onChange 事件 e.target.value 的用法

[上述两个问题的解答](https://zh-hans.reactjs.org/docs/forms.html)

- response.ok 代替了 try……catch？
  该属性是来检查 response 的状态是否在 200 - 299（包括 200 和 299）这个范围内。该属性返回一个布尔值

#### 3-2 用状态提升分享数组状态，完成工程列表页面

核心思想就是把 state(状态) 数据放在大组件上(ProjectList 组件上，然后把数据通过 props 传递给小组件 即数据自上向下传递 --- 这是 React 的核心思想)

修改 json-server 使用的端口

```
package.json:
"json-server": "json-server __json_server_mock__/db.json --watch --port 新端口"
```

创建.env 文件 和 .env.development 文件 这里的操作很厉害 这里跟 webpack 的内容是有一定关系的

注意： 使用 process.env...之前要重启项目

- .find() 函数的使用，知道是啥意思，以及如何使用(以及 find 和 ?. 的搭配)

- url 后跟`/路径`和后端数据 属性之间的关系 例如： http://localhost:3002/projects 和 db.json 文件 projects 属性之间的关系？

- url 后面跟的参数 ?...&... 这些参数有什么用？ 是自己随便想的吗？还是用来对应后端数据的(mysql 的用法)？

在 src 文件夹下创建了一个 utils 文件夹。 cleanObject 功能是把传入的值为空的对象删掉(但是要知道，在一个函数里，改变传入的对象本身是不好的(讲究函数式编程中不可变值的理念才行，用 es6 解构赋值，创建个新的对象，对新的对象进行操作)...(因为对象是引用类型的，别人用了你的函数，结果对人家原来的对象有改变本身就不好))

Object.keys(对象).forEach(key => ...) // 遍历对象的键并对其进行修改！！ 这招牛啊！！
delete object[key] // 这招也厉害 删除对象的属性

人家对于排除 value = 0 值为 false 的方法 用得也妙！！
总而言之，utils 文件夹里的文件代码写得着实妙啊！

`!!`用法 把一个值转化为布尔值，用得巧妙啊！

qs 工具的使用！！ 感觉还可以！

```
安装： npm i qs
使用时要引入qs
import * as qs from 'qs';
```

一个关于 url 参数的问题

> 注意 在 React 中 select 标签有 value 值，且 value 值应该是数字才行

#### 为什么列表要加 key 属性，以及为什么用 index 是不好的

人家说得很好了，我就略了

#### 3-4 学习自定义 Hook - 用 useDebounce 减少工程搜索请求频率

将只执行一次的 useEffect 抽象出来，用 custom hook(把这里的文件放在 utils 里面)
注意，自定义 hook 一定要以 use 开头，否则报错(因为自定义 hook 里面要用到 react 本身提供的 hook，hook 不能在普通函数里使用，只能在组件或者自定义 hook 中使用)

搜索页面进行防抖操作(避免每按一个键盘按钮，就发一个请求)
debounce 专门用来处理快速的事件

```
普通的debounce操作 运用了闭包操作
const debounce = (func, delay) => {
  let timeout;     // 无论函数执行多少次，timeout只用声明一次
  return () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      func();
    }, delay);    // 如果一直执行debounce则timeout不断恢复为初始值
  }
}

const log = debounce(() => console.log('call'), 5000)
log();
log();
log();   // 只有最后一次log()会被执行 打印 call  前两次，timeout还未执行完就被clear了
```

自己来实现一个

```
useDebounce = (value, delay) => {
  let timeout;
  useEffect(() => {
    if (timeout) {
      clearTimeout(timeout)
    }
    timeout = setTimeout((value) => {return value}, delay)
  }, [value, delay])
}
```

标准的方法(完美的展现了 useEffect 和 useState 的魅力)

```
useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);  // 注意，作为钩子，本身value只会在一次使用的时候有默认值的效果，后面，默认值效果就没了(这里如果不理解 看双越面试 hook 有讲)

  useEffect(() => {
    const timeout = setTimeout(() => setDebounceValue(value), delay)
    return () => clearTimeout(timeout);  // 每次useEffect 函数执行结束后会执行这个返回的函数 (双越教程也有讲！)
  }, [value, delay])

  return debouncedValue;
}
```

自定义 hook 最大的特征是要使用其他 hook。如果不适用其他 hook 的话，就充当普通函数就挺好的，没必要弄成自定义 hook

看是否防抖成功是看的 控制台的 network 栏，不是打印栏。。

注意一两个细节：

1. useEffect 如果有 return 返回值，应该是只能返回函数(有待考察)
2. setTimeout 内部的回调函数不一定非得要 return 值，根据情况来定(clearTimeout 道理一样)

#### 4-1 为什么我们需要 ts 真实场景学习 TS 的必要性

如果使用 JS 写项目，那么大部分的错误都是在 runtime(运行时)的时候发现的。使用 TS 就能够在静态代码中，就能找到其中的一些错误 -> 强类型

把项目中 js 文件改为 ts 文件

当我们声明了或定义了某个东西后，是要给其他人用的，既然如此，给人家用，就要给人家**说明书**(我们知道怎么用，但是别人却不知道), `interface`就充当着说明书的作用

下面一段代码，对于函数参数的类型定义用得真好

```
interface SearchPanelProps {
  users: any[],
  param: {
    name: string,
    personId: string
  },
  setParam: (param: SearchPanelProps['param']) => void;    // 这里用得太妙了！！
}

export const SearchPanel = ({users, param, setParam}: SearchPanelProps) => {

```

注意把之前的 js 文件改为 ts 文件后，由于 qs 没有自带 ts 的类型声明文件(没有类型定义)，需要自己去安装一个 qs 的 ts 类型定义文件 (ts 的定义文件只需放在 dev 依赖里就可以，上线的时候不需要用到)

```
npm i --save-dev @types/qs
```

ts 类型定义文件 后缀： .d.ts(说明书文件而已。 .d.ts 文件只是为 js 的核心文件打补丁用的，实质开发时，我们不太常用)

接口之间也能嵌套使用

```
interface User {
  id: string;
  name: string;
  email: string;
  title: string;
  organization: string;
}

interface SearchPanelProps {
  users: User[],       // 接口之间也能嵌套使用
  param: {
    name: string,
    personId: string
  },
  setParam: (param: SearchPanelProps['param']) => void;    // 这里真的就非常讲究了
}
```

几个有意思的点：

```
1.对于对象的类型定义 object
export const cleanObject = (object: object) => ...

2.//@ts-ignore  可以忽略下一行的代码是否使用ts

3.在ts中 如果函数有可选参数，可以写成 ？ 如：(value: any, delay?: number) => {...}
```

[ts + react 优秀指导](https://github.com/typescript-cheatsheets/react#function-components)

#### 4-3 ts 知识梳理、总结与提高

useEffect()里面的回调函数，最后的函数要用花括号包裹，且不要 return (应该是这样的)

为什么常见在函数参数那儿要使用类型定义？ 因为参数无法进行类型推断！所以只能用类型定义了！(按理说，所有声明变量的时候都需要声明类型，只是大多数情况会有类型的自动推断)

#### 4-5 学习泛型，用泛型增强 useDebounce 类型灵活性

例如 useState 其实也是使用了泛型来定义生成的值是什么类型
![泛型1](./imgs/泛型1.png)

泛型优于 typeof 这种能够判断变量类型的语法的地方在于判断类型的时机不一样 泛型在写代码的时候就能判断出类型(静态时发生)。而 typeof 只能在 runtime 的时候才能判断出变量类型

定义泛型的第一件事就是在函数名后面 加`<任意字母(大写)>`

对于箭头函数和普通函数 泛型的位置不一样
例如：

```
// 箭头函数(文件后缀名ts)
const func = <V>(param: V) => ...

// 箭头函数(文件后缀名tsx)
const func = <V extends unknown>(param: V) => ...

// 普通函数
function func<V>(param: V) => ...
```

#### 5-1 用 React 表单、TS 的类型继承和鸭子类型实现登录表单

在 screens 文件夹里创建一个文件夹 login 来实现登录效果
而相比于 React17 项目的登录窗口依赖于 antd，这里是自己用 js 来写(更能展现 js 的能力)

**对于泛型的理解**，使用泛型，我认为一定有一个模板，这个模板有变量(一般用 T 来表示)被<>包裹，而如果要使用这个模板，就要确定<>里的具体类型(就不能再写变量，而是写具体的类型)

比如，有时候会迷惑为啥别人提供的泛型接口我不用变量表示呢？因为人家已经在“后台”给我们弄好了模板，我们是在使用人家的模板，所以应该在<>里写具体的类型，而不是又重复写无意义的变量如 T

ts 是鸭子类型： 面向接口编程 而不是 面向对象编程

登录，一般都是使用`POST`请求吧？！,并且在 post 请求里，似乎一定要指明 Content-Type 类型！！

json.stringify 是把一个 js 对象或值转化为 JSON 字符串

json-server 的一大限制在于只能模拟标准的 REST api，登录接口是不符合 json-server 的模拟规范的。(事实上，对于项目也不可能全部都符合 REST api 的情况) 用下面的方法，可以让 json-server 来模拟非 REST api 的情况

```
实现原理：json-server里的middleware

在__json_server_mock__文件夹下，创建一个middleware.js 文件
然后用nodejs的语法(CMDjs)来写内容：
// 我TM估计，这里写的就是后端的内容(只不过是nodejs罢了) 就是自己来写一个后端接口
module.exports = (req, res, next) => {
  if (req.method === 'POST' && req.path === '/login') {
    if (req.body.username === 'jack' && req.body.password === '12345') {
      // 请求成功后，返回的状态码
      return res.status(200).json({
        user: {
          token: '123'
        }
      })
    } else {
        return res.status(400).json({message: '用户名或密码错误'})
    }
  }
  next();
}
然后在package.json 里配置...
"json-server": "json-server __json_server_mock__/db.json --watch --port 3001 --middlewares ./__json_server_mock__/middleware.js"

注意：使用json-server前要开启json才行
```

这一节，对于 login/index.tsx 文件 form 表格的使用非常经典。但是我也有几个困惑：

- 1. e.preventDefault() 用法 : **在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认表单提交行为。你必须显式的使用 preventDefault --React 官网** form 的默认行为是表单提交后，会跳转刷新到 action 页面。

- 2. 神奇的(e.currentTarget.elements[0] as HTMLInputElement).value 操作
     我在 react17 里做了 currentTarget 以及 target 的区别。 currentTarget 永远指向事件绑定的元素
     as HTMLInputElement 是强制为 HTMLInputElement 类型(原本是 Element 类型)
     这里的内容最好先死记。

- 3. 以及 fetch 第二个参数的一系列操作
     post 请求似乎要指定 header，而且还要是如下这种

```
const response = await fetch(`${apiUrl}/login`, {
    method: 'POST',
    // 这一步的headers似乎是POST请求必写的内容
    headers: {
      'Content-Type': 'application/json'    // 因为要传入json格式的文件 (post请求似乎一定要这样写才行)
    },
    body: JSON.stringify(param)  // 把传入的对象json化
  });
  if (response.ok) {

  }
```
