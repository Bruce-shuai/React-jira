jira 项目需要用到的技术栈： React + hooks + ts + react-query(这是啥？) + react-router + react-toolkit + css in js

react-query 来管理**服务端**全局状态 Performant and powerful data synchronization for React
redux toolkit 管理**客户端**全局状态

可以多对比 React 17 教程

#### 2-1 用 Create react app 初始化项目

如何初始化一个 ts + react 项目方法就不说了。 React17 项目笔记已经说得非常明白了

初始化项目后：src 文件夹里的 react-app-env.d.ts、reportWebVitals.ts、setupTests.ts 这三个文件需知道是有什么作用(目前还未知，但项目完成之后应该是要知道才行的)

**注意**: 源代码里如果要使用图片、字体、文件都应该放在 src 文件夹里，然后放在项目里如模块一般使用，而不是放在如 pulic 这类在 src 文件夹之外的文件夹里

#### 2-2 配置 eslint、prettier 和 commitlint 规范工程

这一节的配置内容，对于团队的合作、代码格式化有好处(和本次项目其实关系不太大)

**问题 1: 引用文件 相对路径过长**

```
例如： import { calculate } from '../../entry....

解决办法：
首先，在tsconfig.json 文件 加一个配置
"baseUrl": "./src"    // 表示绝对路径会去src文件夹下去找
此时，就可以直接写成  import { calculate } from 'entry';   // 但其实还是有点懵
```

导入文件： import ... from './' 和 没有 './'有啥区别？

**格式化代码**
这个感觉挺牛逼的(挺方便的，只要提交到 git，就会自动格式化代码)
让团队写代码有统一规范的格式：
Prettier 工具
首先安装 Prettier：

```
npm install --save-dev --save-exact prettier

echo {}> .prettierrc.json    // echo 是新建一个文件的意思

npx mrm lint-staged    // Prettier hooks
 npm add eslint-config-prettier// 对eslint 要有一些配置
 .... 还是看视频吧...
```

和 vscode 的 prettier 还是有点区别

**提交 commitlint 这个我其实觉得不太方便，算了，不用，有兴趣就看**

#### 2-3 对比常见 Mock 方案 配置 JSON SERVER

(由于在真实环境中，后端和前端并行开发，所以在前期是没有后端接口可以使用的，所以学会最适合自己的 Mock 数据的方法就是非常重要的，下面列举业界常见的 Mock 方案，并选择其中最合适的方案)

##### 1.代码侵入(直接在代码中写死 Mock 数据，或者请求本地的 JSON 文件)

说实话，React 17 就是用的这种方法 估计是应该项目比较简单的原因

优点: 无
缺点:

1. 和其他方案比 Mock 效果不好
2. 与真实 Server 环境的切换非常麻烦(应该不麻烦吧？！)，一切需要侵入代码切换环境的行为都是不好的

##### 2.请求拦截

代表: Mock.js (这是啥？没用过)
帮我们生成随机数据

优点:

1. (相对于代码侵入而言)与前端代码分离
2. 可生成随机数据

缺点:

1. 数据都是动态生成的假数据，无法真实模拟增删改查的情况
2. 只支持 ajax,不支持 fetch

##### 3. 接口管理工具

代表: rap、swagger, moco, yapi(大公司才有)

优点：

1. 配置功能强大，接口管理与 Mock 一体，后端修改接口 mock 也跟着更改，可靠

缺点：

1. 配置复杂，依赖后端，可能会出现后端不愿意出售，或者等配置完了，接口也开发初拉力了的情况。
2. 一般作为大团队的基础建设而存在，没有这个条件的话慎重考虑

##### 4. 本地 node 服务器

代表：json-server

优点：

1. 配置简单，json-server 甚至可以 0 代码，30 秒就启动一个 REST api Server(又是 rest api)
2. 自定义程度高，一切尽在掌握中
3. 增删改查真实模拟
   缺点：
4. 与接口管理工具相比，无法随着后端 api 的修改而自动修改(这个自己也用不着)

```
安装方法：
npm i json-server -g   // 加上sudo 表示全局

启动server： json-server --watch json文件

结合postman 来使用
```

使用 Postman 注意下图几点
必须是 POST 请求 才能设置请求体。且格式应该为 json
![注意事项](./imgs/json-server注意.png)

有一个比较神奇的点： 我通过 postman 可以更改已经有的数据。更改方法竟然是先在 url 后面/id 跟一个要更改内容的 id。 然后把请求方式改为 PATCH。这是什么操作？(为什么会这样？)。删除方式就是 DELETE

url 后跟参数，这里的内容要多研究研究啊

妈的，什么时候我竟然安装了 yarn 的！哈哈

```
在项目中使用json-server
1. yarn add json-server -D
2. 在根目录新建一个文件夹：__json_server_mock__ (前面__表示文件夹是作为辅助文件存在的)
3. ...
4. 运行： npm run json-server
```

[fetch 知识](https://zhuanlan.zhihu.com/p/24594294)

[PATCH 和 PUT 方法的区别](https://segmentfault.com/q/1010000005685904)

#### 3-1 用 JSX 列表渲染开发工程列表页面

先用 js 来写列表渲染。后面再用 ts 来写

这里很有意思，把一个大组件(ProjectListScreen) 由几个小组件(List 组件、SearchPanel 组件)来拼凑出来

并且这个项目中，起文件名的方式是 - 代替驼峰命名(search-panel 代替 SearchPanel)

> 这一节的重点在于 js 和 react 结合后对于 input、option、onChange 的掌握如何！

**因此，总结一点小知识**

- input 标签 常用 的 type 类型
- onChange 事件 e.target.value 的用法

[上述两个问题的解答](https://zh-hans.reactjs.org/docs/forms.html)

- response.ok 代替了 try……catch？
  该属性是来检查 response 的状态是否在 200 - 299（包括 200 和 299）这个范围内。该属性返回一个布尔值

#### 3-2 用状态提升分享数组状态，完成工程列表页面

核心思想就是把 state(状态) 数据放在大组件上(ProjectList 组件上，然后把数据通过 props 传递给小组件 即数据自上向下传递 --- 这是 React 的核心思想)

修改 json-server 使用的端口

```
package.json:
"json-server": "json-server __json_server_mock__/db.json --watch --port 新端口"
```

创建.env 文件 和 .env.development 文件 这里的操作很厉害 这里跟 webpack 的内容是有一定关系的

注意： 使用 process.env...之前要重启项目

- .find() 函数的使用，知道是啥意思，以及如何使用(以及 find 和 ?. 的搭配)
  find() 方法返回数组中满足提供的测试函数的第一个元素的值

```
const array1 = [5, 12, 8, 130, 44];
const found = array1.find(element => element > 10);   // 有返回才行
console.log(found);
```

- url 后跟`/路径`和后端数据 属性之间的关系 例如： http://localhost:3002/projects 和 db.json 文件 projects 属性之间的关系？

- url 后面跟的参数 ?...&... 这些参数有什么用？ 是自己随便想的吗？还是用来对应后端数据的(mysql 的用法)？

在 src 文件夹下创建了一个 utils 文件夹。 cleanObject 功能是把传入的值为空的对象删掉(但是要知道，在一个函数里，改变传入的对象本身是不好的(讲究函数式编程中不可变值的理念才行，用 es6 解构赋值，创建个新的对象，对新的对象进行操作)...(因为对象是引用类型的，别人用了你的函数，结果对人家原来的对象有改变本身就不好))

Object.keys(对象).forEach(key => ...) // 遍历对象的键并对其进行修改！！ 这招牛啊！！

`forEach()` 方法对**数组**的每个元素执行一次给定的函数。

```
const array1 = ['a', 'b', 'c'];
array1.forEach(element => console.log(element));    // 有返回值的
```

**Object.keys()** 方法会返回一个由一个给定对象的自身可枚举属性组成的**数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。

delete object[key] // 这招也厉害 删除对象的属性

人家对于排除 value = 0 值为 false 的方法 用得也妙！！
总而言之，utils 文件夹里的文件代码写得着实妙啊！

`!!`用法 把一个值转化为布尔值，用得巧妙啊！

qs 工具的使用！！ 感觉还可以！
[qs 工具的基本介绍](https://juejin.cn/post/6844904126808227848)

```
安装： npm i qs
使用时要引入qs
import * as qs from 'qs';
```

一个关于 url 参数的问题

> 注意 在 React 中 select 标签有 value 值，且 value 值应该是数字才行

#### 为什么列表要加 key 属性，以及为什么用 index 是不好的

人家说得很好了，我就略了

#### 3-4 学习自定义 Hook - 用 useDebounce 减少工程搜索请求频率

将只执行一次的 useEffect 抽象出来，用 custom hook(把这里的文件放在 utils 里面)
注意，自定义 hook 一定要以 use 开头，否则报错(因为自定义 hook 里面要用到 react 本身提供的 hook，hook 不能在普通函数里使用，只能在组件或者自定义 hook 中使用)

搜索页面进行防抖操作(避免每按一个键盘按钮，就发一个请求)
debounce 专门用来处理快速的事件

```
普通的debounce操作 运用了闭包操作
const debounce = (func, delay) => {
  let timeout;     // 无论函数执行多少次，timeout只用声明一次
  return () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      func();
    }, delay);    // 如果一直执行debounce则timeout不断恢复为初始值
  }
}

const log = debounce(() => console.log('call'), 5000)
log();
log();
log();   // 只有最后一次log()会被执行 打印 call  前两次，timeout还未执行完就被clear了
```

自己来实现一个

```
useDebounce = (value, delay) => {
  let timeout;
  useEffect(() => {
    if (timeout) {
      clearTimeout(timeout)
    }
    timeout = setTimeout((value) => {return value}, delay)
  }, [value, delay])
}
```

标准的方法(完美的展现了 useEffect 和 useState 的魅力)

```
useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);  // 注意，作为钩子，本身value只会在一次使用的时候有默认值的效果，后面，默认值效果就没了(这里如果不理解 看双越面试 hook 有讲)

  useEffect(() => {
    const timeout = setTimeout(() => setDebounceValue(value), delay)
    return () => clearTimeout(timeout);  // 每次useEffect 函数执行结束后会执行这个返回的函数 (双越教程也有讲！)
  }, [value, delay])

  return debouncedValue;
}
```

自定义 hook 最大的特征是要使用其他 hook。如果不适用其他 hook 的话，就充当普通函数就挺好的，没必要弄成自定义 hook

看是否防抖成功是看的 控制台的 network 栏，不是打印栏。。

注意一两个细节：

1. useEffect 如果有 return 返回值，应该是只能返回函数(有待考察)
2. setTimeout 内部的回调函数不一定非得要 return 值，根据情况来定(clearTimeout 道理一样)

#### 4-1 为什么我们需要 ts 真实场景学习 TS 的必要性

如果使用 JS 写项目，那么大部分的错误都是在 runtime(运行时)的时候发现的。使用 TS 就能够在静态代码中，就能找到其中的一些错误 -> 强类型

把项目中 js 文件改为 ts 文件

当我们声明了或定义了某个东西后，是要给其他人用的，既然如此，给人家用，就要给人家**说明书**(我们知道怎么用，但是别人却不知道), `interface`就充当着说明书的作用

下面一段代码，对于函数参数的类型定义用得真好

```
interface SearchPanelProps {
  users: any[],
  param: {
    name: string,
    personId: string
  },
  setParam: (param: SearchPanelProps['param']) => void;    // 这里用得太妙了！！
}

export const SearchPanel = ({users, param, setParam}: SearchPanelProps) => {

```

注意把之前的 js 文件改为 ts 文件后，由于 qs 没有自带 ts 的类型声明文件(没有类型定义)，需要自己去安装一个 qs 的 ts 类型定义文件 (ts 的定义文件只需放在 dev 依赖里就可以，上线的时候不需要用到)

```
npm i --save-dev @types/qs
```

ts 类型定义文件 后缀： .d.ts(说明书文件而已。 .d.ts 文件只是为 js 的核心文件打补丁用的，实质开发时，我们不太常用)

接口之间也能嵌套使用

```
interface User {
  id: string;
  name: string;
  email: string;
  title: string;
  organization: string;
}

interface SearchPanelProps {
  users: User[],       // 接口之间也能嵌套使用
  param: {
    name: string,
    personId: string
  },
  setParam: (param: SearchPanelProps['param']) => void;    // 这里真的就非常讲究了
}
```

几个有意思的点：

```
1.对于对象的类型定义 object
export const cleanObject = (object: object) => ...

2.//@ts-ignore  可以忽略下一行的代码是否使用ts

3.在ts中 如果函数有可选参数，可以写成 ？ 如：(value: any, delay?: number) => {...}
```

[ts + react 优秀指导](https://github.com/typescript-cheatsheets/react#function-components)

#### 4-3 ts 知识梳理、总结与提高

useEffect()里面的回调函数，最后的函数要用花括号包裹，且不要 return (应该是这样的)

为什么常见在函数参数那儿要使用类型定义？ 因为参数无法进行类型推断！所以只能用类型定义了！(按理说，所有声明变量的时候都需要声明类型，只是大多数情况会有类型的自动推断)

#### 4-5 学习泛型，用泛型增强 useDebounce 类型灵活性

例如 useState 其实也是使用了泛型来定义生成的值是什么类型
![泛型1](./imgs/泛型1.png)

泛型优于 typeof 这种能够判断变量类型的语法的地方在于判断类型的时机不一样 泛型在写代码的时候就能判断出类型(静态时发生)。而 typeof 只能在 runtime 的时候才能判断出变量类型

定义泛型的第一件事就是在函数名后面 加`<任意字母(大写)>`

对于箭头函数和普通函数 泛型的位置不一样
例如：

```
// 箭头函数(文件后缀名ts)
const func = <V>(param: V) => ...

// 箭头函数(文件后缀名tsx)
const func = <V extends unknown>(param: V) => ...

// 普通函数
function func<V>(param: V) => ...
```

#### 5-1 用 React 表单、TS 的类型继承和鸭子类型实现登录表单

在 screens 文件夹里创建一个文件夹 login 来实现登录效果
而相比于 React17 项目的登录窗口依赖于 antd，这里是自己用 js 来写(更能展现 js 的能力)

**对于泛型的理解**，使用泛型，我认为一定有一个模板，这个模板有变量(一般用 T 来表示)被<>包裹，而如果要使用这个模板，就要确定<>里的具体类型(就不能再写变量，而是写具体的类型)

比如，有时候会迷惑为啥别人提供的泛型接口我不用变量表示呢？因为人家已经在“后台”给我们弄好了模板，我们是在使用人家的模板，所以应该在<>里写具体的类型，而不是又重复写无意义的变量如 T

ts 是鸭子类型： 面向接口编程 而不是 面向对象编程

登录，一般都是使用`POST`请求吧？！,并且在 post 请求里，似乎一定要指明 Content-Type 类型！！

json.stringify 是把一个 js 对象或值转化为 JSON 字符串

json-server 的一大限制在于只能模拟标准的 REST api，登录接口是不符合 json-server 的模拟规范的。(事实上，对于项目也不可能全部都符合 REST api 的情况) 用下面的方法，可以让 json-server 来模拟非 REST api 的情况

```
实现原理：json-server里的middleware

在__json_server_mock__文件夹下，创建一个middleware.js 文件
然后用nodejs的语法(CMDjs)来写内容：
// 我TM估计，这里写的就是后端的内容(只不过是nodejs罢了) 就是自己来写一个后端接口
module.exports = (req, res, next) => {
  if (req.method === 'POST' && req.path === '/login') {
    if (req.body.username === 'jack' && req.body.password === '12345') {
      // 请求成功后，返回的状态码
      return res.status(200).json({
        user: {
          token: '123'
        }
      })
    } else {
        return res.status(400).json({message: '用户名或密码错误'})
    }
  }
  next();
}
然后在package.json 里配置...
"json-server": "json-server __json_server_mock__/db.json --watch --port 3001 --middlewares ./__json_server_mock__/middleware.js"

注意：使用json-server前要开启json才行
```

这一节，对于 login/index.tsx 文件 form 表格的使用非常经典。但是我也有几个困惑：

- 1. e.preventDefault() 用法 : **在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认表单提交行为。你必须显式的使用 preventDefault --React 官网** form 的默认行为是表单提交后，会跳转刷新到 action 页面。

- 2. 神奇的(e.currentTarget.elements[0] as HTMLInputElement).value 操作
     我在 react17 里做了 currentTarget 以及 target 的区别。 currentTarget 永远指向事件绑定的元素
     as HTMLInputElement 是强制为 HTMLInputElement 类型(原本是 Element 类型)
     这里的内容最好先死记。

- 3. 以及 fetch 第二个参数的一系列操作
     post 请求似乎要指定 header，而且还要是如下这种

```
const response = await fetch(`${apiUrl}/login`, {
    method: 'POST',
    // 这一步的headers似乎是POST请求必写的内容
    headers: {
      'Content-Type': 'application/json'    // 因为要传入json格式的文件 (post请求似乎一定要这样写才行)
    },
    body: JSON.stringify(param)  // 把传入的对象json化
  });
  if (response.ok) {

  }
```

#### 5-2 连接真实服务器 - 专属开发者工具介绍与安装

这个开发者工具用 MSW 以 `Service Worker` 为原理实现了“分布式后端”

```
安装： npx imooc-jira-tool
```

如果一直安装不起。 先卸载 node_modules 然后再运行 `npx imooc-jira-tool` 再 npm i

#### 5-4 JWT 原理与 auth-provider 实现

(JWT 其实在 React17 项目里讲得比较明白了)
token 是后端返回来的
(token 放在了 客户端的 localstorage 里面)
JWT:

创建一个 auth-provider.ts 文件(这个文件(始终是放在 src 文件夹里的)里写几个函数用来帮助我们操控 jwt 里的 token)

```
auth-provider.ts
// 在真实环境中，如果使用firebase这种第三方auth服务的话，本文件不需要开发者开发

const localStorageKey = '__auth_provider_token__';

const apiUrl = process.env.REACT_APP_API_URL;

/* 获取token */
export const getToken = () => window.localStorage.getItem(localStorageKey);    // 从浏览器里的localStorage里获取token

/* 服务器响应的数据(token)放在localStorage里 */
// 注意这里的参数 ts 格式   这里的user 外面的{} 用的是解构方法，毕竟后端解析的数据这里只需要user的内容
export const handleUserResponse = ({user}:{user: User}) => {
  window.localStorage.setItem(localStorageKey, user.token || '')  // 这里的 || 符号用得好
  return user;
}

/* 用户登录的函数 */
const login = async (data: {username: string, password: string}) => {
  const response = await fetch(`${apiUrl}/login`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  })
  if (response.ok) {
    // 感觉这里不用return应该也可以吧？！
    return handleUseResponse(await response.json())
  }
}

/* 用户注册的函数 */
const register = async (data: {username: string, password: string}) => {
  const response = await fetch(`${apiUrl}/register`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  })
  if (response.ok) {
    // 感觉这里不用return应该也可以吧？！
    return handleUseResponse(await response.json())
  }
}

/* 用户注销的函数 */
const logout = () => window.localStorage.removeItem(localStorageKey)
```

#### 5-5 用 useContext 存储全局用户信息

(又是 context 挺有意思的) React 17 其实也是有详细的讲解的

这里似乎是想用 context 来代替 redux
用专门的一个文件夹 context 来放置 全局数据

```
  context
    |--index.ts
    |--auth-context.tsx
```

useState 钩子想要指定参数类型，就<>内部定义泛型的具体类型

```
例如：
const [user, setUser] = useState<User | null>(null)
```

**point free 这个用法搞不懂！**

context 对象提供一个生产者(provider)和消费者(consumer)

遇见的困难是根本无法进行调试

关于 children 的讲解

```
<div>
  <h2>学习</h2>
</div>

等于下面的代码

<div children={<div><h2>学习</h2></div>} />

children 专属 ts类型，ReactNode(需要从react里导入)


注意，如果要在一个组件标签里显示写children，则该标签必须是闭合标签 例如
✅
<AuthProvider children={children} />
❌
<AuthProvider children={children}>
</AuthProvider>
```

**牛逼的是，可以把 children 当作 props 来从组件间传递数据**

#### 5-6 用 useAuth 切换登录与非登录状态

创建一个文件夹 unauthenticated-app 用来装未登录的状态。(需要装载登录 注册 文件)
创建一个文件 authenticated-app.tsx 用来装登录的状态

有一个小 tips 需要注意： response.json() 在一个作用域里只能写一次
![json-error](./imgs/json-error.png)

**发现了一个问题： 似乎在 if 语句里面 不能写 jsx 语法 ❌ 好像是可以用 jsx 语法的**

#### 5-7 用 fetch 抽象通用 HTTP 请求方法，增强通用性

保持登录状态(持久性登录) 想想 react17 项目是怎么实现的呢？ 有点忘了！！

封装函数，让异步请求具有通用性。 这种函数作为工具函数，放在 utils 里面

token 标准格式：Bearer(开头) + token

下面这两个用法要熟悉才行
**window.location.reload() 用法**
**response.status 用法**

**注意一个关于`fetch`的问题** fetch 后跟 catch。catch 只会在断网或者网络连接失败的时候才会抛出异常。如果是为了捕获服务端抛出的异常，应该有 if else 逻辑且 else 里面放置 return Promise.reject(data)。 那么问题来了，如果是 try……catch 能有效解决问题吗？(但是要注意，axios 却可以直接返回状态不为 2xx 的时候抛出异常)

nodejs 的知识还得好好学学才行... 的的确确需要后端知识才行啊。。这次项目弄完后 花 15 天还是好好弄弄 nodejs(双越项目) 真的 把 nodejs 搞清楚后，http 的理解就会深很多

#### 额外知识补充:TS type vs interface

#### 5-8 用 useHttp 管理 JWT 和登录状态，保持登录状态

有一个疑问是现在的 env 文件起到了什么作用？ 在哪起的作用？

解决页面刷新需重新登录问题：
原因： auth-context.tsx 文件 user 默认值不能是 null

#### 5-9 TS 的联合类型、partial 和 Omit 介绍

**Utility Types** 充当工具的类型

```
// 联合类型(...或...的类型)
let myFavoriteNumber: string | number
myFavoriteNumber = 7;
myFavoriteNumber = 'seven'

// 类型别名
type jackFavoriteNumber = string | number

在很多情况下，类型别名和interface是可以互换的。二者主要的两个区别如下：
1. interface 无法实现联合类型或交叉类型,但是 type 可以实现
type test1 = string | number
type test2 = string & number

2. interface 也没法实现Utility Type
(ts中的typeof 和 js中的typeof 二者是不一样的， js的typeof，是在runtime时运行的，ts中的typeof是在静态环境中运行的)
Parameters<typeof http>    // typeof 能够读出http是一个函数类型。Parameters能够读出<>里面函数类型的参数是什么类型。 这个功能和React 17里面 的 ReturnType 功能很像啊

但是能写type的时候尽量写type

utility type的用法： 用泛型给它传入一个其他类型，然后utility type 对这个类型进行某种操作

type Person = {
  name: string,
  age: number
}
// Partial<> 也是一个Utility Type
const xiaoMing: Partial<Person> = {age: 8}   // name，age都变成可选属性了
const shenMiRen: Omit<Person, 'name'> = {age: 8}    // 只能用age属性，无法有name
```

#### 5-10 TS 的 Utility Types-Pick、Exclude、Partial 和 Omit 实现

```
// Partial 的实现
type Partial<T> = {
  // keyof 是依次把对象的键取出来  in就是遍历的功能
  [P in keyof T]?: T[P]
}

// Omit 的实现
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

上面的 Untility 有待之后网上好好查

#### 6-1 安装和使用 antd 组件库

使用 antd + emotion
以及 flex 和 grid 使用

先安装 antd

然后在 index.tsx 文件 导入 antd(这次后缀是 less，因为要自定义 antd 的主题变量)

```
import 'antd/dist/antd/less'
```

从使用 antd 的 Form 可以看出，Form 组件的使用，让原本的 form 标签方便使用了好多...

#### 6-2 为什么我们需要 CSS-in-JS 方案 - 通过传统 CSS 缺陷学习 CSS-in-JS 必要性

#### 最受欢迎的 CSS-in-JS 方案 - Emotion 的安装与使用

```
html {
  使用 rem 相对单位
  16 * 62.5% = 10px  // 浏览器默认的字体大小 16px？
  1 rem === 10px
  font-size: 62.5%;
}
```

```
安装emotion方法：
yarn add @emotion/react @emotion/styled
```

#### 6-3【扩展学习】不再惧怕 CSS CSS-in-JS

[CSS-in-JS](https://coding.imooc.com/lesson/482.html#mid=41843)

emotion 里 控制变量的方法着实感觉不错
emotion 对于写行内样式也非常优秀，可以解决原来 React 里行内样式无法处理级联、伪类等情况

#### 6-4 最受欢迎的 CSS-in-JS 方案 - Emotion

这里须知全局样式放在了 App.css 文件里

```

html {
// 这里的用法非常有意思
// rem 相对于根元素 html 的 font-size (注意是 font-size)
// 浏览器默认的 font-size 是 16px
// 16 \* 62.5% = 10px 即 1 rem = 10 px
font-size: 62.5%;
}
```

```

安装 emotion 的方法:

```

yarn add @emotion/react @emotion/styled

```

如果要在文件中使用 css in js。先导入

```

import styled from '@emotion/styled';

```


安装一个对应的语法高亮的插件： vscode-styled-components
似乎react17 的那个css module 也是可以的
```

这种操作和 css Module 还是有一定的不同的

需要注意的是 emotion 用法
对于 html 自带的元素，这样来写

最后生成的都是组件

```
const Test = styled.div `

`
```

如果是例如 antd 带的组件样式修改如下

```
const Test = styled(Input) `
`
```

这样看来似乎是要比 css module 更好用(针对于可以修改 antd 组件样式 并且挺方便的)

注意 `` 就是模板字符串的符号

```
const Header = styled.header `
  background: url(${logo});   // url里面就不用再写 ``了，因为外层就是``
`
```

这一节有个难点 即 对于 background 的使用
多背景 很有意思

```
const Background = styled.div`
  position: absolute;
  width: 100%;
  height: 100%;
  background-repeat: no-repeat;    // 图像不重复
  background-attachment: fixed;    // 在视口内固定
  background-position: left bottom, right bottom;
  background-size: calc(((100vw - 40rem) / 2) - 3.2rem),
    calc(((100vw - 40rem) / 2) - 3.2rem), cover;
  background-image: url(${left}), url(${right});
`;
```

**background**

1. `background-repeat` CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。

2. `background-attachment` CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。

3. `background-position` 为每一个背景图片设置初始位置。 这个位置是相对于由 background-origin 定义的位置图层的。

4. `background-size` 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。

5. `background-image` 属性用于为一个元素设置一个或者**多个背景图像。**

这里的多背景图片是真的有意思

#### Grid 和 Flex

grid-area 用来给 grid 子元素起名字

grid 和 flex 各自的应用场景

1. 要考虑 是一维布局还是二维布局
   一般来说，一维布局用 flex, 二维布局用 grid
2. 是从内容触发还是从布局出发？
   从内容出发：你先有一组内容(数量一般不固定)，然后希望他们均匀的分布在容器中，有内容自己的大小决定占据的空间
   从布局触发：先规划网格(数量一般比较固定)，然后把元素往里填充

从内容出发，用 flex
从布局触发，用 grid

[grid 视频教程](https://www.bilibili.com/video/BV18p411A7JB?from=search&seid=6906517803541556396)
[grid 文章](https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

#### 6-6 用 CSS-in-JS 状态工程创建自定义组件： Row 组件实现

emotion 的变量功能 感觉很厉害
在 src 文件夹下创建一个 components 文件夹 用来存放可以重用的项目级别的组件
这一节 emotion 使用变量是真的厉害

#### 6-7 完善项目列表样式

使用 emotion 的 内联样式要在该文件下引入下面的内容

```
/**@jsx jsx */
import {jsx} from '@emotion/react';
```

**将时间戳转化为当前时间的方法(专门处理时间的库)**

```
// 安装库
yarn add dayjs

大致展示一下使用方法
{project.created ? dayjs(project.created).format('YYYY-MM-DD') : '无'}
```

**针对 svg 图片可以来一点骚操作**
以 svg 的操作

```
import {ReactComponent as SoftwareLogo} from 'assets/software-logo.svg';
以这般步骤导出svg组件 SoftwareLogo。
这样就可以对svg组件当作组件进行样式操作了
例如：
<SoftwareLogo width={'18rem'} color={'rgb(...)'} />
```

#### 6-8 清除前面课程留下的警告信息

**注意**： 在 ts 中，object 类型不仅指 键值对类型的对象，还指函数，正则表达式...
所以如果对一个函数进行解构操作，则会出现这种情况

```
const b = {...() => {}};      // b 就是一个空对象
```

如果想要表示一个类型是键值对。则应该像下面一样来写

```
{[key:string]:unknown}   // unknown 类似 any 但比any 更加的严谨

let b: { [key: string]: unknown }
```

注意，如果要用超链接 a 就要使用 href。并且如果 href={'#'} 只写一个#是不合法的。如果你想让一个按钮有超链接的样式效果，但又不需要 href。建议使用 antd 的 Button。antd 有个 Button， type='link'的按钮。这个按钮很好

还要注意一件事情: useEffect 中的依赖项里加上 callback 会造成无限循环，这个和 useCallback 以及 useMemo 有关系

这里对 react-query 也进行了一定的操作。就不详说了

#### 6-9 你觉得 CSS-in-JS 的方案适合你吗？

**tailwindcss**效果怎么样？
有空可以试试

#### 7-1 给页面添加 Loading 和 Error 状态，增加页面友好性

这里的加载中应该是比 React 17 项目里的转菊花要高级一些
说白了，就是优雅的控制 react 项目中的异步操作。以简单的方式提高用户体验

`Error` 也是一种 ts 类型

#### 7-2 用高级 Hook-useAsync 统一处理 Loading 和 Error 状态

这节难度挺大的

**有趣的一个知识点 js 解构赋值中使用别名**

```
const object = { number: 10 }
const { number } = object
// 使用别名
const { number: otherNumber } = object
console.log(otherNumber) //10
```

#### 复盘前面所学的内容，看看代码，再调整调整代码，理清思路

突然发现，项目几乎全部是以函数的方式来完成的，函数和函数的搭配

发现一个问题： 当使用 usestate 对数据进行更新，并不能立刻获取到最新的数据。
[对应比较好的文章](https://segmentfault.com/a/1190000040013137)

[point free](https://www.ruanyifeng.com/blog/2017/03/pointfree.html)

#### 7-3 登录注册页面 Loading 和 Error 状态处理，与 Event Loop 详解

竟然还有 `onError` 事件
try...catch 执行 异步的时候需要注意注意 使用 async await 代替 promise 解决出现的 promise 中 event loop 情况

确认密码，这个可以直接使用 antd 的方法。也可以自己写。(教程里的就是自己写的)

`response.ok`会在状态码为 2xx 的时候返回 true 其余情况返回 false

```
catch消化异常问题

 return promise
    .then(data => {
      setData(data);
      return data;
    }).catch(error => {
      // catch 会消化异常(??)，如果不主动抛出，外面是接受不到异常的
      setError(error);
      return error;    // 这里的消化异常指的是 即使在catch里，只要代码没报错，会被下一个then接收而非catch接收(双越)
      // 主动抛出异常的方法
      // return Promise.reject(error);
    }).then(err => {
      console.log('err', err);   // 如果前一个catch执行，这里的then会被执行，而不是下一个catch执行

    }).catch(err => {
      console.log('err-catch', err);
    })
```

**注意：useState 是异步执行(event loop 原则，先同步执行，再执行异步代码)** 但 setState 本身是一个同步函数
(要看一个函数是同步还是异步，就看它的返回值。你可以看一下 setState 的类型签名，会发现返回 void 而不是 Promise)

[stackOverflow 里关于 useState 的讨论](https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately)

#### 7-4 用 useAsync 获取用户信息

#### 7-5 实现 Error Boundaries 捕获错误边界

```
// <{children: ReactNode, fallbackRender: FallbackRender}, any> 可以写成 React.Component<React.PropsWithChildren<{fallbackRender: FallbackRender}>>
export class ErrorBoundary extends React.Component<{children: ReactNode, fallbackRender: FallbackRender}, any>
```

#### 8-1、 8-2 用 useRef 实现 useDecumentTitle - useRef 与 Hook 闭包详解

文档标题 (用自定义的 hook 来改变文档标题)
**React**有 2 种方案

1. 使用 react helmet
2. 自定义一个 hook

针对 useEffect 处理闭包问题是有讲究的

useEffect 依赖问题(如果有多个依赖，必须多个依赖都变化才会触发 useEffect 重新使用？)似乎只要有一个变化就行

#### 8-3 添加项目列表和项目详情路由

[react router@6 文档](https://github.com/ReactTraining/react-router/blob/dev/docs/api-reference.md)

对于单页面应用，路由是必不可少的东西。React Router 是 react 中运用最广的路由库

v6 版本的 react-router 比 v5 版本 在 api 的使用上有巨大的更新
安装方法：

```
yarn add react-router@6 react-router-dom@6

yarn add history
```

都安装 beta 版本的

强转字符串的方法： String()

#### 8-4 添加看板和任务组路由
